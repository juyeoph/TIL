# ✨ JPA 영속성 컨텍스트와 `@Modifying` 문제 해결

오늘은 JPA의 핵심 개념인 영속성 컨텍스트와, `@Query`, `@Modifying` 어노테이션을 함께 사용할 때 발생할 수 있는 동기화 문제 및 해결 방법에 대해 정리합니다.

## 1. 🔍 영속성 컨텍스트(Persistence Context)란?

JPA(Java Persistence API)의 핵심 개념으로, 애플리케이션과 데이터베이스 사이에서 **엔티티(Entity) 객체를 효율적으로 관리하기 위한 논리적인 공간 또는 캐시**입니다. 영속성 컨텍스트는 `EntityManager`를 통해 접근하고 관리됩니다.

**주요 역할:**

* **1차 캐시 (First-Level Cache):**
    * 엔티티를 저장하거나 조회하면, 1차 캐시에 엔티티 객체가 저장됩니다.
    * 동일한 엔티티를 다시 조회할 때 데이터베이스에 접근하지 않고 1차 캐시에서 엔티티를 반환하여 성능을 최적화합니다.
* **동일성 보장 (Identity Guarantee):**
    * 하나의 트랜잭션 내에서 같은 엔티티(동일한 식별자)를 여러 번 조회해도 항상 같은 엔티티 인스턴스를 반환합니다.
* **트랜잭션을 지원하는 쓰기 지연 (Transactional Write-Behind):**
    * 엔티티를 저장(`persist()`)하거나 변경하더라도 즉시 SQL 쿼리를 데이터베이스에 날리지 않습니다.
    * 변경 내용을 '쓰기 지연 SQL 저장소'에 모아두었다가, 트랜잭션이 커밋되는 시점에 한 번에 데이터베이스에 반영합니다.
* **변경 감지 (Dirty Checking):**
    * 엔티티가 1차 캐시에 저장될 때 초기 상태(스냅샷)를 함께 저장합니다.
    * 트랜잭션 커밋 시, 엔티티의 현재 상태와 스냅샷을 비교하여 변경된 부분이 있다면 자동으로 `UPDATE` 쿼리를 생성하고 데이터베이스에 반영합니다. 개발자가 직접 `update()` 메서드를 호출할 필요가 없습니다.
* **지연 로딩 (Lazy Loading):**
    * 연관 관계에 있는 엔티티를 당장 필요로 하지 않을 때 즉시 로딩하지 않고, 실제로 사용되는 시점에 데이터베이스에서 데이터를 가져오는 기능입니다. 영속성 컨텍스트는 '프록시 객체'를 활용하여 이를 가능하게 합니다.

## 2. ⚠️ `@Query`와 `@Modifying` 함께 사용 시 문제

`@Query` 어노테이션은 주로 `SELECT` 쿼리(조회)에 사용되며, `@Modifying` 어노테이션은 `INSERT`, `UPDATE`, `DELETE` 쿼리(변경)에 사용됩니다. 이 둘을 함께 사용할 때 영속성 컨텍스트 캐시와 데이터베이스 데이터가 동기화되지 않는 문제가 발생할 수 있습니다.

**문제 발생 원인:**

1.  **`@Query` (조회):** 일반적으로 영속성 컨텍스트(1차 캐시)를 거쳐 데이터를 조회합니다. 조회된 엔티티는 영속성 컨텍스트에 캐싱되어 관리됩니다.
2.  **`@Modifying` (변경):** 이 어노테이션이 붙은 쿼리는 **영속성 컨텍스트를 우회하여 데이터베이스에 직접 SQL 쿼리를 실행**합니다. 즉, 영속성 컨텍스트가 관리하는 엔티티의 상태를 직접적으로 변경하지 않고, 데이터베이스의 데이터를 변경합니다.

문제는 `@Modifying` 쿼리가 데이터베이스를 변경하더라도, **영속성 컨텍스트에 캐싱되어 있는 동일한 엔티티의 상태는 이 변경을 알지 못한다**는 것입니다. 따라서 영속성 컨텍스트에 있는 데이터는 오래된(stale) 상태가 되고, 실제 DB 데이터와 불일치가 발생합니다.

**예시 시나리오:**

1.  `memberRepository.findById(1L)`로 회원을 조회하여 영속성 컨텍스트에 캐싱 (예: `id=1, name='홍길동'`).
2.  `@Modifying` 쿼리 실행: `memberRepository.updateMemberName("김철수", 1L);` (DB에서 `id=1`의 이름이 `김철수`로 변경됨).
3.  영속성 컨텍스트의 `id=1` 회원 객체는 **여전히 `name='홍길동'` 상태**를 유지.
4.  같은 트랜잭션 내에서 `memberRepository.findById(1L)`를 다시 호출하면, DB에 가지 않고 1차 캐시에서 **오래된 데이터(`name='홍길동'`)**를 반환할 수 있음.

## 3. ✅ 해결 방법: `@Modifying(clearAutomatically = true)`

이 문제를 해결하는 가장 일반적이고 효과적인 방법은 `@Modifying` 어노테이션에 `clearAutomatically = true` 옵션을 추가하는 것입니다.

**동작 원리:**

* `@Modifying(clearAutomatically = true)` 쿼리가 실행되면, 데이터베이스에 쿼리가 반영된 직후에 **영속성 컨텍스트를 자동으로 '지워버립니다'(clear).**
* 이는 `EntityManager.clear()` 메서드를 호출하는 것과 동일한 효과를 가집니다.
* 영속성 컨텍스트가 지워지면 그 안에 있던 모든 엔티티 객체들은 관리되지 않는 **준영속(detached) 상태**가 됩니다.
* 이렇게 영속성 컨텍스트가 비워진 상태에서 해당 엔티티(또는 다른 엔티티)를 다시 조회하면, 1차 캐시에 해당 엔티티가 없으므로 **반드시 데이터베이스에 새로운 쿼리를 날려 최신 데이터를 가져오게 됩니다.** 이로써 영속성 컨텍스트와 데이터베이스의 동기화 불일치 문제가 해결됩니다.

**예시 코드:**

```java
public interface MemberRepository extends JpaRepository<Member, Long> {

    @Modifying(clearAutomatically = true) // <-- clearAutomatically = true 추가
    @Query("UPDATE Member m SET m.name = :newName WHERE m.id = :id")
    int updateMemberName(@Param("newName") String newName, @Param("id") Long id);

    // clearAutomatically = true 설정 후 사용 시:
    // 1. memberRepository.updateMemberName("김철수", 1L); 실행
    // 2. DB에 김철수 반영
    // 3. 영속성 컨텍스트 초기화 (이전에 캐싱된 모든 엔티티가 사라짐)
    // 4. 이후 memberRepository.findById(1L); 호출 시 DB에서 최신 '김철수' 데이터를 가져옴
}
```

**유의할 점:**

* `clearAutomatically = true`는 `@Modifying` 쿼리에 의해 변경된 엔티티뿐만 아니라, **해당 영속성 컨텍스트가 관리하던 모든 엔티티를 초기화**합니다.
* 따라서 `@Modifying` 쿼리 이후에도 동일한 트랜잭션 내에서 영속성 컨텍스트에 있던 다른 엔티티들을 계속 사용해야 한다면, 이들이 준영속 상태가 되어 더 이상 변경 감지가 되지 않거나 재조회가 필요한 등의 문제가 발생할 수 있으므로 신중하게 사용해야 합니다.
* 일반적으로 `@Modifying` 쿼리가 트랜잭션의 거의 마지막 부분에 위치하거나, 쿼리 이후에 해당 트랜잭션 내에서 캐시된 엔티티들을 다시 관리할 필요가 없는 경우에 가장 효과적입니다.

---
