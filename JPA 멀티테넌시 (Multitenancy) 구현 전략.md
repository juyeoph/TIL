# 🏢 JPA 멀티테넌시 (Multitenancy) 구현 전략

오늘은 하나의 소프트웨어 인스턴스로 여러 고객(테넌트)에게 서비스를 제공하는 **멀티테넌시(Multitenancy)** 아키텍처와, JPA(Hibernate)를 활용하여 이를 편리하게 구현하는 전략에 대해 정리합니다.

## 1. 🏢 멀티테넌시(Multitenancy)란?

멀티테넌시는 **하나의 소프트웨어 애플리케이션 인스턴스가 여러 독립적인 고객(테넌트)에게 서비스를 제공하는 소프트웨어 아키텍처**입니다. 각 테넌트는 마치 자신만의 독립적인 애플리케이션을 사용하는 것처럼 데이터를 격리하여 사용하지만, 실제로는 동일한 하드웨어, 소프트웨어, 데이터베이스를 공유합니다.

**비유:** 아파트 건물 한 채에 여러 가구가 각자의 독립적인 공간(집)을 가지면서도, 건물의 공용 시설(엘리베이터, 주차장, 관리 시스템)을 공유하는 것과 같습니다.

**멀티테넌시를 구현하는 주요 이유 (장점):**

* **비용 효율성:** 각 고객마다 별도의 서버/DB를 구축할 필요 없이 단일 인프라를 공유하여 인프라 및 운영 비용을 절감합니다.
* **운영 효율성:** 애플리케이션 업데이트, 패치, 유지보수 등을 단일 인스턴스에 한 번만 적용하면 되므로 관리 부담이 줄어듭니다.
* **리소스 최적화:** 여러 테넌트가 자원을 공유하므로, 전체적인 자원 활용률이 높아지고 유휴 자원 낭비를 줄일 수 있습니다.
* **빠른 기능 배포:** 새로운 기능이나 버그 수정이 모든 고객에게 동시에 빠르게 적용됩니다.

**핵심 과제:** 각 테넌트의 데이터가 다른 테넌트에게 노출되거나 섞이지 않도록 **데이터를 철저히 격리**하는 것이 가장 중요합니다.

## 2. 🧩 JPA 수준에서 멀티테넌시 구현의 편리함

멀티테넌시는 언뜻 보면 복잡한 인프라 및 데브옵스 기술이 필요해 보입니다. 그러나 JPA (특히 Hibernate)는 개발자가 가장 많이 상호작용하는 **'데이터 접근' 부분의 복잡성을 추상화하여, 테넌트별 데이터 격리 및 라우팅을 편리하게 자동화**해줍니다.

**JPA가 편리하게 해주는 이유:**

* **코드의 간결성:** 개발자는 비즈니스 로직에서 `WHERE tenant_id = '현재 테넌트 ID'`와 같은 SQL 조건을 직접 작성할 필요가 없습니다.
* **자동 처리:** JPA가 런타임에 현재 요청의 테넌트 ID를 파악하여 데이터베이스 쿼리에 자동으로 해당 테넌트 필터링 조건을 추가하거나, 적절한 데이터베이스/스키마로 연결을 전환해줍니다.
* **개발 생산성 향상:** 개발자가 데이터 격리 로직에 신경 쓸 필요 없이 핵심 비즈니스 로직에 집중할 수 있게 해줍니다.

## 3. 🛡️ JPA 멀티테넌시 구현 전략

JPA(Hibernate)는 주로 다음 세 가지 전략을 통해 멀티테넌시를 지원합니다. 각 전략은 데이터 격리 수준, 비용, 관리 복잡성 측면에서 장단점을 가집니다.

### 3.1. 📊 데이터 분리 (Discriminator Column / Shared Schema with Discriminator)

* **설명:** 모든 테넌트의 데이터를 **하나의 데이터베이스, 하나의 스키마, 하나의 테이블**에 저장합니다. 각 테이블의 모든 행(row)에는 해당 데이터가 어떤 테넌트에 속하는지를 나타내는 **`tenant_id` (또는 `client_id`, `company_id` 등) 컬럼이 추가**됩니다.
* **구분 방식:** 애플리케이션(JPA)이 모든 `SELECT`, `UPDATE`, `DELETE` 쿼리에 `WHERE tenant_id = :currentTenantId` 조건을 자동으로 추가하여, 논리적으로 데이터를 구분합니다.
* **JPA 구현 편의성:**
    * Hibernate는 `@org.hibernate.annotations.TenantId` 어노테이션을 제공하여 엔티티 필드가 `tenant_id`임을 명시하고, 자동 값 설정 및 쿼리 필터링을 지원합니다.
    * 복합 기본 키를 사용할 경우 `@Id`와 `@TenantId`를 함께 사용할 수 있습니다.
* **장점:**
    * **최고의 비용 효율성:** 단일 DB 인스턴스를 공유하므로 인프라 및 운영 비용이 가장 낮습니다.
    * **쉬운 관리:** 새로운 테넌트 추가 시 DB 구조 변경 없이 데이터만 추가하면 됩니다.
    * **자원 활용 효율성:** 모든 테넌트가 자원을 공유하므로 전체적인 자원 활용률이 높습니다.
* **단점:**
    * **논리적 격리:** 물리적 격리가 아니므로, 애플리케이션 코드의 실수(tenant_id 필터링 누락 등)가 데이터 유출로 이어질 수 있는 보안 위험이 가장 큽니다.
    * **성능 확장성:** 테이블 크기가 매우 커질 수 있어 `tenant_id` 컬럼에 대한 인덱싱이 필수적이며, 대규모 데이터에서 성능 병목이 발생할 수 있습니다.
    * **백업/복구 복잡성:** 특정 테넌트 데이터만 백업/복구하기 어렵습니다.

### 3.2. 🏗️ 스키마 분리 (Schema per Tenant)

* **설명:** 하나의 물리적인 데이터베이스 안에 각 테넌트별로 별도의 스키마(Schema)를 생성하여 데이터를 저장합니다. 각 스키마 안에 동일한 테이블 구조를 가집니다.
* **구분 방식:** JPA(Hibernate)는 각 요청에 따라 현재 테넌트에 해당하는 스키마로 데이터베이스 연결의 기본 스키마를 동적으로 전환하여 모든 쿼리가 해당 스키마 내에서 실행되도록 합니다.
* **장점:**
    * **높은 데이터 격리:** 각 테넌트가 자신만의 논리적인 공간을 가지므로 데이터가 더 안전하게 분리됩니다. 애플리케이션 오류로 인한 데이터 유출 위험이 낮습니다.
    * **관리의 균형:** 하나의 DB 인스턴스만 관리하면 되면서도, 스키마 단위로 권한 부여나 백업 전략 수립이 가능합니다.
    * **성능:** 테이블 크기가 스키마별로 분리되므로, 단일 테이블 방식보다 성능 면에서 유리할 수 있습니다.
* **단점:**
    * **관리 오버헤드 증가:** 새로운 테넌트 추가 시 스키마 생성 및 초기화(테이블 생성 등) 작업이 필요합니다.
    * **공유 자원 문제:** 여전히 하나의 물리적인 DB를 공유하므로, 특정 테넌트의 과도한 사용이 다른 테넌트의 성능에 영향을 줄 수 있습니다.

### 3.3. 🗄️ 데이터베이스 분리 (Database per Tenant)

* **설명:** 각 테넌트의 데이터를 **물리적으로 다른 데이터베이스 인스턴스**에 저장합니다.
* **구분 방식:** JPA(Hibernate)는 각 요청에 따라 현재 테넌트에 해당하는 데이터베이스 인스턴스로 연결을 전환하여 쿼리를 실행합니다. (데이터소스 전환)
* **장점:**
    * **최고의 격리 및 보안:** 각 테넌트가 완전히 독립적인 DB를 가지므로, 데이터 유출 위험이 가장 낮고 다른 테넌트의 부하로부터 완전히 독립적입니다.
    * **최적의 성능:** 테넌트별로 DB를 독립적으로 튜닝하고 확장할 수 있습니다.
    * **유연한 백업/복구:** 테넌트별로 독립적인 백업 및 복구 전략을 수립할 수 있습니다.
* **단점:**
    * **가장 높은 비용:** 테넌트 수만큼 DB 라이선스, 인프라, 운영 비용이 기하급수적으로 증가합니다.
    * **최고의 관리 복잡성:** 모든 DB 인스턴스에 대한 배포, 업그레이드, 모니터링 등을 개별적으로 관리해야 합니다.

### 4. 💡 어떤 전략을 선택할까?

| 전략                         | 데이터 격리 수준 | 비용 효율성 | 관리 복잡성 | 주로 선호되는 상황                                             |
| :--------------------------- | :--------------- | :---------- | :---------- | :------------------------------------------------------------- |
| **데이터 분리 (Discriminator Column)** | 낮음 (논리적)    | **높음** | **낮음** | 초기 SaaS, 테넌트 수가 많고 데이터 볼륨이 작을 때             |
| **스키마 분리** | 중간 (논리적/물리적) | 중간        | 중간        | 규모 확장 시, 데이터 격리 요구사항이 중요할 때               |
| **데이터베이스 분리** | **높음 (물리적)** | 낮음        | **높음** | 보안 및 규제가 매우 엄격하고, 비용보다 격리가 우선일 때       |

대부분의 SaaS 애플리케이션은 비용 효율성과 관리 용이성 때문에 **데이터 분리 (Discriminator Column)** 방식을 기본으로 고려하며, 서비스 규모가 커지거나 특정 요구사항이 발생하면 **스키마 분리** 방식으로 전환을 고려하는 경우가 많습니다.

---
