# [TIL] 스프링 프레임워크 동작 방식과 DispatcherServlet의 역할

스프링 프레임워크는 제어의 역전(IoC)과 의존성 주입(DI)이라는 핵심 철학을 바탕으로 동작한다. 개발자가 객체를 직접 관리하는 대신, 스프링 컨테이너가 모든 것을 관리하며 애플리케이션의 전체 흐름을 주도한다. 이 과정을 '거대한 레스토랑'에 비유하여 이해해보자.

> **🍽️ 핵심 비유**
> * **스프링 컨테이너(`ApplicationContext`)**: 레스토랑의 모든 것을 총괄하는 **총지배인**
> * **빈(`Bean`)**: 각 분야의 **전문 직원** (수석 셰프, 웨이터, 창고 관리자 등)
> * **HTTP 요청**: 레스토랑에 찾아온 **손님**

---

## Ⅰ. 스프링 애플리케이션의 생명주기 (레스토랑의 하루)

스프링 애플리케이션은 크게 **시작(개점) → 요청 처리(영업) → 종료(폐점)**의 생명주기를 가진다.

### 1. 시작 (개점 준비)

애플리케이션이 실행되면, **총지배인(스프링 컨테이너)**이 레스토랑을 열기 위해 바쁘게 움직인다.

1.  **컴포넌트 스캔 (직원 명부 확인)**: 총지배인은 `@Component`, `@Service`, `@RestController` 등 특별한 명찰이 붙은 클래스를 모두 찾아내 '채용할 직원 명부'를 만든다.
2.  **빈(Bean) 생성 및 의존성 주입 (직원 채용 및 관계 설정)**: 총지배인은 명부대로 **웨이터(`@RestController`), 수석 셰프(`@Service`)** 등을 채용(객체 생성)하고, 각자에게 필요한 동료를 소개해준다 (`@Autowired`). 예를 들어, 웨이터에게는 수석 셰프를, 수석 셰프에게는 창고 관리자를 연결해준다.
3.  **초기화 (`@PostConstruct` / 개점 준비)**: 모든 직원이 배치되면, 총지배인은 "오픈 준비하세요!"라고 지시한다. 이때 `@PostConstruct`가 붙은 메서드들이 실행되어 각자의 위치에서 최종 준비(예: `GameServer` 실행)를 마친다.

### 2. 요청 처리 (손님 응대)

손님(HTTP 요청)이 레스토랑에 도착하면, 이제 **홀 매니저(`DispatcherServlet`)**가 모든 것을 지휘한다. 이 과정은 아래 `DispatcherServlet` 파트에서 자세히 다룬다.

### 3. 종료 (폐점)

애플리케이션이 종료되면, 총지배인은 "마감 시간입니다!"라고 알린다. 이때 `@PreDestroy`가 붙은 메서드들이 호출되어, 각자 사용하던 자원(네트워크 연결 등)을 안전하게 정리하고 퇴근한다.

---

## Ⅱ. DispatcherServlet 집중 탐구

`DispatcherServlet`은 스프링 MVC의 심장이자 두뇌이며, **프론트 컨트롤러 패턴(Front Controller Pattern)**의 구현체다.

> **👨‍💼 비유: 홀 매니저 또는 공항 관제탑**
> 모든 요청을 가장 먼저 받아 처리할 담당자에게 연결하고, 처리된 결과를 최종적으로 손님에게 전달하는 모든 과정을 총괄 지휘하는 중앙 컨트롤러다.

### `DispatcherServlet`의 역할과 장점

- **중앙 집중 제어**: 모든 요청이 단 하나의 입구(`DispatcherServlet`)를 통과하므로, 보안, 인코딩 등 공통 로직을 한 곳에서 일관되게 처리할 수 있다.
- **유연한 확장**: 개발자는 실제 비즈니스 로직을 담은 컨트롤러 구현에만 집중하면 되므로, 기능의 추가 및 변경이 용이하다.

### 상세 동작 흐름 (시작과 끝)

`DispatcherServlet`은 요청 처리의 **시작과 끝**을 모두 책임진다.

1.  **[시작] 요청 접수**: 클라이언트의 모든 HTTP 요청을 가장 먼저 받는다.
2.  **`HandlerMapping`에 문의**: "이 요청(URL)은 어떤 웨이터(`@Controller`)가 담당해야 합니까?"라고 묻는다.
3.  **`HandlerAdapter`를 통해 실행**: 담당 웨이터를 찾아, 그 웨이터의 행동 방식에 맞게 요청을 전달하고 실행시킨다.
4.  **컨트롤러 로직 처리**: 웨이터(`@Controller`)는 주문을 받아 수석 셰프(`@Service`)에게 전달하여 실제 비즈니스 로직을 처리한다.
5.  **[끝] 결과 수신 및 응답 생성**: 컨트롤러로부터 처리 결과(데이터 객체 또는 뷰 이름)를 돌려받는다.
6.  결과를 보고 최종 손님에게 보여줄 형태(JSON 문자열 또는 HTML 페이지)로 가공하고 포장한다.
7.  완성된 HTTP 응답을 손님(클라이언트)에게 전달하며 모든 과정을 마무리한다.

```
[클라이언트] <=> [DispatcherServlet] <=> [Controller, Service, Repository]
    ↑       (시작)         (끝)       ↑
    |         |                      |
    +----요청--+                      +--응답--+
```
