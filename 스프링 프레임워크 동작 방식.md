# 스프링 프레임워크 동작 방식과 DispatcherServlet의 역할

스프링 프레임워크는 제어의 역전(IoC: Inversion of Control)과 의존성 주입(DI: Dependency Injection)이라는 핵심 철학을 바탕으로 동작합니다. 개발자가 객체의 생성, 생명 주기, 의존성 관계를 직접 관리하는 대신, **스프링 컨테이너**가 이 모든 것을 관리하며 애플리케이션의 전체 흐름을 주도합니다.

---

## Ⅰ. 스프링 애플리케이션의 생명주기

스프링 애플리케이션은 크게 **시작 → 요청 처리 → 종료**의 생명주기를 가집니다.

### 1. 시작 (애플리케이션 초기화)

애플리케이션이 실행되면, 스프링 컨테이너(`ApplicationContext`)가 애플리케이션 구동을 위해 필요한 초기화 작업을 수행합니다.

1.  **컴포넌트 스캔:** 스프링 컨테이너는 `@Component`, `@Service`, `@RestController` 등 스프링이 관리할 대상으로 지정된 어노테이션이 붙은 클래스들을 스캔하여 컨테이너에 등록할 대상들을 식별합니다.
2.  **빈(Bean) 생성 및 의존성 주입:** 식별된 클래스들을 기반으로 객체(빈)를 생성하고, `@Autowired`와 같은 어노테이션을 통해 각 빈이 필요로 하는 다른 빈들을 자동으로 연결(주입)해줍니다.
3.  **초기화 (`@PostConstruct`):** 모든 빈의 생성 및 의존성 주입이 완료되면, `@PostConstruct` 어노테이션이 붙은 메서드들이 실행되어 각 빈의 최종 초기화 작업을 수행합니다 (예: 외부 시스템 연결, 캐시 로딩 등).

### 2. 요청 처리

클라이언트로부터 HTTP 요청이 발생하면, 이제 **`DispatcherServlet`**이 요청을 처리하는 중심적인 역할을 수행합니다. 이 과정은 아래 `DispatcherServlet` 파트에서 자세히 다룹니다.

### 3. 종료 (애플리케이션 소멸)

애플리케이션이 종료되면, 스프링 컨테이너는 관리하던 빈들을 소멸시키고 사용하던 자원들을 정리합니다. 이때 `@PreDestroy` 어노테이션이 붙은 메서드들이 호출되어, 각 빈이 사용하던 자원(예: 네트워크 연결, 파일 핸들)을 안전하게 해제하고 정리합니다.

---

## Ⅱ. DispatcherServlet 집중 탐구

`DispatcherServlet`은 스프링 MVC의 핵심 컴포넌트이자 프론트 컨트롤러 패턴(Front Controller Pattern)의 구현체입니다.

### `DispatcherServlet`의 역할과 장점

* **중앙 집중 제어:** 모든 HTTP 요청을 가장 먼저 받아 처리하는 단일 진입점 역할을 합니다. 이를 통해 보안, 인코딩, 로깅 등 공통적으로 적용해야 할 로직을 한 곳에서 일관되게 처리할 수 있습니다.
* **모듈화 및 확장성:** 요청 처리 흐름을 여러 컴포넌트(예: `HandlerMapping`, `HandlerAdapter`, `ViewResolver` 등)로 위임하여 모듈화를 촉진합니다. 개발자는 비즈니스 로직을 담은 컨트롤러 구현에만 집중할 수 있으며, 기능의 추가 및 변경이 용이합니다.

### 상세 동작 흐름

`DispatcherServlet`은 클라이언트 요청의 **시작과 끝**을 모두 담당하며, 다음과 같은 과정을 통해 요청을 처리합니다.

1.  **요청 접수:** 클라이언트의 모든 HTTP 요청을 가장 먼저 수신합니다.
2.  **`HandlerMapping` 조회:** 수신된 요청(URL)을 처리할 수 있는 **핸들러(Controller 메서드)**를 찾기 위해 등록된 `HandlerMapping`들에게 문의합니다.
3.  **`HandlerAdapter` 실행:** `HandlerMapping`으로부터 찾아낸 핸들러(Controller 메서드)와 그에 맞는 `HandlerAdapter`를 사용하여 실제 핸들러(컨트롤러)를 실행시킵니다.
4.  **컨트롤러 로직 처리:** 핸들러(컨트롤러)는 요청을 받아 실제 비즈니스 로직을 수행하는 서비스 계층의 컴포넌트와 상호작용합니다.
5.  **`ModelAndView` 반환:** 컨트롤러는 처리 결과로 `ModelAndView` 객체(데이터와 뷰 이름 포함) 또는 단순히 데이터 객체를 `DispatcherServlet`에게 반환합니다.
6.  **`ViewResolver`를 통한 뷰 처리 (필요시):** 컨트롤러가 뷰 이름을 반환한 경우, `DispatcherServlet`은 `ViewResolver`를 통해 해당 뷰 이름에 해당하는 뷰 객체를 찾습니다.
7.  **뷰 렌더링 또는 응답 데이터 변환:** 뷰 객체를 사용하여 데이터를 HTML 페이지로 렌더링하거나 (예: JSP), 컨트롤러가 반환한 데이터 객체를 JSON/XML과 같은 형태로 변환합니다 (예: `@ResponseBody` 사용).
8.  **응답 전송:** 최종적으로 생성된 HTTP 응답(렌더링된 HTML 페이지 또는 변환된 데이터)을 클라이언트에게 전달하며 요청 처리를 완료합니다.

```
[클라이언트] <--- HTTP 요청/응답 ---> [DispatcherServlet] <---> [HandlerMapping]
                                          ↓
                                      [HandlerAdapter]
                                          ↓
                                    [Controller (핸들러)] <---> [Service, Repository]
                                          ↓
                                    [ModelAndView 반환]
                                          ↓
                                      [ViewResolver]
                                          ↓
                                        [View]
                                          ↓
                                        [렌더링]
                                          ↓
                                    [클라이언트로 응답]
```
