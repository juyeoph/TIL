# HashMap vs. synchronizedMap vs. ConcurrentHashMap 비교 정리

자바에서 `Map` 인터페이스는 매우 유용하지만, 멀티스레드 환경에서는 어떤 구현체를 선택하느냐에 따라 시스템의 안정성과 성능이 크게 달라질 수 있다. 각 `Map` 구현체의 특징과 올바른 사용처를 정리한다.

## 1. `HashMap` 🚗

> 비유: 아무런 교통 규칙이 없는 교차로

`HashMap`은 동기화(Synchronization) 처리가 전혀 되어있지 않다.

### 특징
- ❌ **스레드 안전성(Thread-Safety) 없음**: 여러 스레드가 동시에 `HashMap`에 접근하여 데이터를 수정하면 데이터가 오염되거나 유실되고, 최악의 경우 무한 루프에 빠져 시스템이 멈출 수 있다.
- 💨 **최고의 성능 (단일 스레드 기준)**: 동기화 오버헤드가 없으므로, 단일 스레드 환경에서는 가장 빠른 성능을 보여준다.

### 언제 사용하는가?
- **단일 스레드 환경에서만 사용**해야 한다.
- 여러 스레드가 접근할 일이 없는, **메서드 내의 지역 변수**로 선언하여 임시 데이터를 처리할 때 가장 이상적이다. (예: 특정 요청을 처리하는 동안만 사용하는 임시 데이터 저장)

```java
// 메서드 안에서만 사용하는 '지역 변수'일 때 가장 이상적
public void processData() {
    Map<String, Integer> tempData = new HashMap<>();
    // ...
}
```

## 2. `Collections.synchronizedMap` 🏛️

> 비유: 한 번에 한 사람만 들어갈 수 있는 관공서

`Collections.synchronizedMap`은 `HashMap`을 래핑(wrapping)하여 모든 메서드에 `synchronized` 키워드를 붙인 것과 같다.

### 특징
- ✅ **스레드 안전성 보장**: 모든 메서드가 동기화 처리되어 있어 여러 스레드가 접근해도 데이터가 깨지지 않는다.
- ⛓️ **맵 전체를 잠그는 단일 잠금 (Global Lock)**: 어떤 스레드든 `Map`에 접근(`get`, `put` 등)하는 순간, **맵 객체 전체에 잠금**이 걸린다.
- 🐢 **성능 병목 현상**: 하나의 스레드가 맵을 사용하는 동안 다른 모든 스레드는 대기해야만 한다. 동시 요청이 많은 서버 환경에서는 성능을 심각하게 저하시키는 주범이 될 수 있다.

### 언제 사용하는가?
- 스레드 안전성은 필요하지만, **동시 수정이 거의 발생하지 않는 환경**에서 간단하게 동기화를 구현하고 싶을 때 사용을 고려할 수 있다. (예: 서버 시작 시 초기화되고 거의 변하지 않는 전역 설정값 캐시)
- 현대적인 자바 개발에서는 `ConcurrentHashMap`에 밀려 사용 빈도가 매우 낮다.

```java
// 맵 전체가 하나의 잠금으로 관리됨
Map<String, String> synchronizedMap = Collections.synchronizedMap(new HashMap<>());
```

## 3. `ConcurrentHashMap` 🏢

> 비유: 여러 개의 독립된 창구가 있어 동시에 업무 처리가 가능한 관공서

`ConcurrentHashMap`은 스레드 안전성을 보장하면서도 높은 동시 처리 성능을 위해 탄생했다.

### 특징
- ✅ **스레드 안전성 보장**
- 🚀 **높은 동시성(High Concurrency)**: `synchronizedMap`과 달리 맵 전체를 잠그지 않는다.
- ✨ **세분화된 잠금 (Fine-grained Lock)**: 데이터를 저장하는 내부 구조를 여러 개의 구역(Segment 또는 Bucket)으로 나누어, 데이터를 수정할 때 **해당 구역만 잠근다.**
- 따라서 여러 스레드가 맵의 서로 다른 구역에 있는 데이터에 대해서는 대기 없이 동시에 접근하여 수정할 수 있다.

### 언제 사용하는가?
- **높은 동시성이 요구되는 서버 환경의 공유 자원 관리**에 가장 적합한 표준적인 선택이다.
- 여러 스레드가 빈번하게 데이터를 읽고 쓰는 상황에서 데이터의 안전성과 시스템 성능을 모두 확보해야 할 때 사용한다. (예: 사용자별 세션 관리, 실시간 데이터 집계, 캐시 등)

```java
// 높은 동시성을 보장하는 가장 이상적인 선택
ConcurrentMap<String, UserSession> userSessions = new ConcurrentHashMap<>();
```

## 🏁 한눈에 보는 비교 표

| 구분 | `HashMap` | `Collections.synchronizedMap` | `ConcurrentHashMap` |
| :--- | :--- | :--- | :--- |
| **스레드 안전성** | ❌ 없음 | ✅ 있음 | ✅ 있음 |
| **잠금 방식** | - | 맵 전체를 잠금 (Global Lock) | 데이터 일부만 잠금 (Fine-grained Lock) |
| **성능** | 단일 스레드에서 최상 | 동시성 환경에서 느림 | 동시성 환경에서 빠름 |
| **추천 사용처** | 메서드 내 지역 변수 | 동시 수정이 드문 공유 데이터 | 동시 수정이 잦은 공유 데이터 |
| **핵심 비유** | 규칙 없는 교차로 | 1인용 관공서 | 다중 창구 관공서 |
